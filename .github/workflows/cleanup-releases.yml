name: cleanup-releases
on:
  push:
    branches: [ main ]
    paths:
      - '.github/cleanup-tags.txt'

permissions:
  contents: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - id: read
        run: |
          if [ ! -f .github/cleanup-tags.txt ]; then
            echo "No cleanup file found; nothing to do."
            echo "tags=" >> $GITHUB_OUTPUT
            exit 0
          fi
          TAGS=$(grep -E '^[^#[:space:]]' .github/cleanup-tags.txt | tr '\n' ' ')
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
      - name: Delete releases and tags
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const raw = `${{ steps.read.outputs.tags }}`;
            const tags = (raw || '').trim().split(/\s+/).filter(Boolean);
            if (!tags.length) {
              core.info('No tags to clean up.');
              return;
            }
            const {owner, repo} = context.repo;
            for (const tag of tags) {
              core.info(`Processing ${tag}`);
              // delete release by tag if exists
              try {
                const rel = await github.rest.repos.getReleaseByTag({owner, repo, tag});
                await github.rest.repos.deleteRelease({owner, repo, release_id: rel.data.id});
                core.info(`Deleted release for ${tag}`);
              } catch (e) {
                core.info(`No release for ${tag} or already deleted`);
              }
              // ensure remote tag deleted
              try {
                await github.rest.git.deleteRef({owner, repo, ref: `tags/${tag}`});
                core.info(`Deleted remote ref tags/${tag}`);
              } catch (e) {
                core.info(`Tag ${tag} ref not found or already deleted`);
              }
            }
